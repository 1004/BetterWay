/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_pecoo_blurjnidemo_NativeHelper */
#ifndef _Included_com_pecoo_blurjnidemo_NativeHelper
#define _Included_com_pecoo_blurjnidemo_NativeHelper
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_pecoo_blurjnidemo_NativeHelper
 * Method:    blurBitmap
 * Signature: (Ljava/lang/Object;I)V
 */
#include <android/log.h>
#include <android/bitmap.h>
#include "stackblur.h"   // 在第一步中创建的.h头文件，下面可以调用里面的方法

// log宏定义
#define TAG "Native_Blur_Jni"
#define LOG_D(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__)

JNIEXPORT void JNICALL Java_com_android_betterway_utils_BlurUtil_blurBitmap
        (JNIEnv *env, jclass obj, jobject bitmapIn, jint r)
{
    AndroidBitmapInfo infoIn;
    void *pixels;
    // 获取bitmap的信息
    if (AndroidBitmap_getInfo(env, bitmapIn, &infoIn) != ANDROID_BITMAP_RESULT_SUCCESS) {
        LOG_D("AndroidBitmap_getInfo failed!");
        return;
    }
    // 检测bitmap是不是这两种格式，因为算法中只有对这两种图片会做处理
    if (infoIn.format != ANDROID_BITMAP_FORMAT_RGBA_8888 &&
        infoIn.format != ANDROID_BITMAP_FORMAT_RGB_565) {
        LOG_D("Only support ANDROID_BITMAP_FORMAT_RGBA_8888 and ANDROID_BITMAP_FORMAT_RGB_565");
        return;
    }
    // 锁定图片
    if (AndroidBitmap_lockPixels(env, bitmapIn, &pixels) != ANDROID_BITMAP_RESULT_SUCCESS) {
        LOG_D("AndroidBitmap_lockPixels failed!");
        return;
    }
    // 得到宽高
    int h = infoIn.height;
    int w = infoIn.width;
    if (infoIn.format == ANDROID_BITMAP_FORMAT_RGBA_8888) {
        // 调用stackblur.c中的blur_ARGB_8888()或blur_RGB_565()
        pixels = blur_ARGB_8888((int *) pixels, w, h, r);
    } else if (infoIn.format == ANDROID_BITMAP_FORMAT_RGB_565) {
        pixels = blur_RGB_565((short *) pixels, w, h, r);
    }
    // 对应上面的AndroidBitmap_lockPixels（）
    AndroidBitmap_unlockPixels(env, bitmapIn);
}
#ifdef __cplusplus
}
#endif
#endif